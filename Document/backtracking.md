# backtracking

- 기본적으로 백트래킹은 `가능한 모든 방법을 탐색한다.`는데 기본 아이디어가 있다. 
- 대표적인 완전 탐색 방법으로는 DFS가 있다. 

DFS는 현재 지점에서 방문해야할 곳이 있으면 재귀 호출을 이용해서 계속 이동한다. DFS의 장점은 무한히 깊은 곳을 찾아야할 때 효과적이다. 하지만 DFS는 모든 곳을 방문하기 때문에 굳이 목표지점이 있지 않는 경로에 빠져서 비효율적인 결과를 초래할 수 있다. 

이런 비효율적인 경로를 차단하고 목표지점에 갈 수 있는 가능성이 있는 루트를 검사하는 방법이 백트래킹 알고리즘이다. 

백트래킹은 DFS에 가지치기를 통해 가도되지 않는 루트는 고려하지 않고 탐색하는 완전탐색 기법이다. 

#### 예제 1.

##### N-Queen

크기가 N * N인 체스판 위에 퀸 N 개를 서로 공격할 수 없게 놓는 문제이다.  N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오 

N * N의 체스판에 을 (1, 1) 부터 시작하여 모든 위치를 트리로 만들었다고 가정했을 때 DFS를 이용하면 퀸이 움직일 수 있는 모든 경우의 수를 확인할 수 있다. 하지만 이미 가치가 없어진 경우의 수는 배제해야 한다. 그렇지 않으면 너무 많은 경우의 수를 확인해야 한다. 그렇기 때문에 **가지치기를 적절하게 사용해야 한다. **

#### 7.1 수행과정 

1. DFS 수행 :
   - 먼저 평소와 같이 DFS를 수행하여 노드를 찾는다. 
2. 유망한 노드 검토:
   - 방문한 노드를 포함해서 유망한 노드이면 서브트리로 이동하고 그렇지 않으면 백트래킹을 수행한다. 
3. 방문한 노드의 하위 노드로 이동하여 다시 재ㅟ를 통해 DFS를 수행한다. 
4. 백트래킹 수행 : 
   - 방문한 노드를 가지치기를 하고 상위 노드로 백트래킹한 후 DFS를 다시 수행한다. 

```java
public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    n = sc.nextInt();

    for (int i = 1; i <= n; i++) {
        // 첫번째 퀸의 시작점은 행을 기준. (i = 1) => (1, 1), (i = 2) => (1, 2), (i = 3) => (1, 3)
        col = new int[16];
        col[1] = i;

        // 1. DFS 수행 (다음 열인 2열 이동)
        dfs(2);
    }

    // 정답 출력
    System.out.println(ans);
}

static void dfs(int row) {
    // 현재 열이 체스판을 넘어 섰으면
    if (row > n) {
        ++ans;
    } else {
        for (int i = 1; i <= n; i++) {
            // 현재 위치하고 있는 노드의 좌표를 저장 (row: 열, i: 행)
            col[row] = i;

            // 2. 유망한 노드 검토
            if (isPossible(row)) {
                // 3. 서브 트리 이동 (해당 노드의 하위 노드)
                dfs(row + 1);
            } else {
                // 4. 백트래킹 수행, 해당노드는 가지치기 되어진다.
                col[row] = 0;
            }
        }
    }
}

static boolean isPossible(int c) {
    // 이전 열들을 탐색하면서 유망한 노드인지 확인
    for (int i = 1; i < c; i++) {
        // 상위 노드에서 같은 행에 퀸이 있는지 여부
        if (col[i] == col[c]) {
            return false;
        }
        // 대각선 검사, 상위 노드의 퀸과 현재 노드의 퀸의 가로 세로 거리가 같은지 검사
        if (Math.abs(col[i] - col[c]) == Math.abs(i - c)) {
            return false;
        }
    }
    return true;
}
```

